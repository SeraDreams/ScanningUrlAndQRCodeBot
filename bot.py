import time
from urllib.parse import urlparse
from aiogram.utils import executor
from config import *
from src.convert_qrcode_to_link import get_link_qr_code
from src.link_check import check_link
from aiogram.dispatcher import FSMContext
from utils import States
from keyboards import keyboard, keyboard_start, keyboard_menu
from all_bot_messages import error_qrcode, error_url, error_ban_url, instruction, greetings, output_table


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç —Ñ–ª—É–¥–∞
async def anti_flood(message: types.Message, *args, **kwargs):
    await message.delete()


@dp.message_handler(commands=['start'])
@dp.throttled(anti_flood, rate=1)
async def process_start_command(message: types.Message):
    await message.answer(greetings, reply_markup=keyboard_start)


@dp.message_handler(text='–ù–∞—á–∞—Ç—å üöÄ')
@dp.throttled(anti_flood, rate=1)
async def start_menu(message: types.Message, state: FSMContext):
    await message.answer('–í—ã–±–µ—Ä–∏—Ç–µ <b>–æ–¥–Ω–æ</b> –∏–∑ –¥–µ–π—Å—Ç–≤–∏–π:\n\n1‚É£ --> URL\n\n2‚É£ --> QRCode', reply_markup=keyboard_menu)


@dp.message_handler(commands=["qr_code"])
@dp.throttled(anti_flood, rate=1)
async def cmd_qrcode(message: types.Message, state: FSMContext):
    await state.set_state(States.all()[0])
    await bot.send_message(message.from_user.id, "‚¨ÜÔ∏è –û—Ç–ø—Ä–∞–≤—å <b>QR-–∫–æ–¥</b>, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—á–µ—à—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å: ‚¨ÜÔ∏è")


@dp.message_handler(commands=["url"])
@dp.throttled(anti_flood, rate=1)
async def cmd_url(message: types.Message, state: FSMContext):
    await state.set_state(States.all()[1])
    await bot.send_message(message.from_user.id, "üìù –ù–∞–ø–∏—à–∏ <b>URL</b>, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—á–µ—à—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å: üìù")


@dp.message_handler(commands=["help"])
@dp.throttled(anti_flood, rate=1)
async def cmd_help(message: types.Message):
    await message.answer(instruction)


@dp.message_handler(text='–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å—Å—ã–ª–∫—É üëÄ')
@dp.throttled(anti_flood, rate=1)
async def processing_url(message: types.Message, state: FSMContext):
    await state.set_state(States.all()[1])
    await bot.send_message(message.from_user.id, "–ù–∞–ø–∏—à–∏ <b>URL</b>, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—á–µ—à—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å: ", reply_markup=keyboard)


@dp.message_handler(text='–û—Ç–ø—Ä–∞–≤–∏—Ç—å QR-Code üì©')
@dp.throttled(anti_flood, rate=1)
async def processing_qr_code(message: types.Message, state: FSMContext):
    await state.set_state(States.all()[0])
    await bot.send_message(message.from_user.id, "–û—Ç–ø—Ä–∞–≤—å <b>QR-–∫–æ–¥</b>, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—á–µ—à—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å: ",
                           reply_markup=keyboard)


@dp.message_handler(text='–ù–∞–∑–∞–¥ ‚Ü©Ô∏è', state=States.QR_STATE[0])
@dp.throttled(anti_flood, rate=1)
async def processing_qr_code(message: types.Message, state: FSMContext):
    await state.reset_state()
    await message.answer('üîÑ <b>–ò–î–Å–¢ –ü–ï–†–ï–ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï –í –ì–õ–ê–í–ù–û–ï –û–ö–ù–û, –ü–û–ñ–ê–õ–£–ô–°–¢–ê, –ü–û–î–û–ñ–î–ò–¢–ï...</b> üîÑ')
    time.sleep(0.5)
    await message.answer("–í—ã –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é, –≤—ã–±–µ—Ä–∏—Ç–µ <b>–æ–¥–Ω–æ</b> –∏–∑ –¥–µ–π—Å—Ç–≤–∏–π:\n\n1‚É£ --> URL\n\n2‚É£ --> QRCode",
                         reply_markup=keyboard_menu)


@dp.message_handler(text='–ù–∞–∑–∞–¥ ‚Ü©Ô∏è', state=States.URL_STATE[0])
@dp.throttled(anti_flood, rate=1)
async def processing_url(message: types.Message, state: FSMContext):
    await state.reset_state()
    await message.answer('üîÑ <b>–ò–î–Å–¢ –ü–ï–†–ï–ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï –í –ì–õ–ê–í–ù–û–ï –û–ö–ù–û, –ü–û–ñ–ê–õ–£–ô–°–¢–ê, –ü–û–î–û–ñ–î–ò–¢–ï...</b> üîÑ')
    time.sleep(0.5)
    await message.answer("–í—ã –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é, –≤—ã–±–µ—Ä–∏—Ç–µ <b>–æ–¥–Ω–æ</b> –∏–∑ –¥–µ–π—Å—Ç–≤–∏–π:\n\n1‚É£ --> URL\n\n2‚É£ --> QRCode",
                         reply_markup=keyboard_menu)


@dp.message_handler(state=States.URL_STATE[0])
@dp.throttled(anti_flood, rate=1)
async def solution_url(message: types.Message, state: FSMContext):
    url = message.text
    await message.reply("üîÖ –ò–¥—ë—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Å—ã–ª–∫–∏... üîÖ", reply=False)
    time.sleep(1)
    try:
        parsed_url = urlparse(url)
        domain = parsed_url.scheme + '://' + parsed_url.netloc + '/'
        result = check_link(domain)
        time.sleep(1)
        await message.reply(output_table(domain=domain, result=result), reply=False)
        await state.set_state(States.all()[1])
    except:
        try:
            parsed_url = urlparse(url)
            domain = 'http://' + parsed_url.netloc + '/'
            result = check_link(domain)
            time.sleep(1)
            await message.reply(error_ban_url, parse_mode='HTML', reply=False)
            time.sleep(1)
            await message.reply(output_table(domain=domain, result=result), parse_mode="HTML", reply=False)
            await state.set_state(States.all()[1])
        except:
            await message.reply(error_url, parse_mode='HTML', reply=False)
            await state.set_state(States.all()[1])


@dp.message_handler(state=States.QR_STATE[0], content_types=['photo'])
@dp.throttled(anti_flood, rate=1)
async def solution_qrcode(message: types.Message, state: FSMContext):
    await message.reply("‚¨áÔ∏è –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–∫–∞—á–∏–≤–∞–µ—Ç—Å—è... ‚¨áÔ∏è", reply=False)
    time.sleep(1)
    user_id = message.from_user.id
    await message.photo[-1].download(f'src/img_{user_id}.png')
    try:
        url = get_link_qr_code(user_id=user_id)
        await message.reply("üîÖ –ò–¥—ë—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Å—ã–ª–∫–∏... üîÖ", reply=False)
        time.sleep(1)
        try:
            time.sleep(1)
            parsed_url = urlparse(url)
            domain = parsed_url.scheme + '://' + parsed_url.netloc + '/'
            result = check_link(domain)
            await message.reply(output_table(domain=domain, result=result), reply=False)
            await state.set_state(States.all()[0])
        except:
            try:
                time.sleep(1)
                parsed_url = urlparse(url)
                domain = 'http://' + parsed_url.netloc + parsed_url.path
                result = check_link(domain)
                await message.reply(error_ban_url, parse_mode='HTML', reply=False)
                time.sleep(1)
                await message.reply(output_table(domain=domain, result=result), parse_mode='HTML', reply=False)
                await state.set_state(States.all()[0])
            except:
                await message.reply("<b>‚ö†Ô∏è –°—Å—ã–ª–∫–∞ –≤ QR-–∫–æ–¥–µ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è... ‚ö†Ô∏è</b>", parse_mode='HTML', reply=False)
                await state.set_state(States.all()[0])
    except:
        await message.reply(error_qrcode, parse_mode='HTML', reply=False)
        await state.set_state(States.all()[0])


@dp.message_handler(content_types=['text'])
@dp.throttled(anti_flood, rate=1)
async def handle_text(message: types.Message):
    await message.answer("–¢–∞–∫–æ–π –∫–æ–º–∞–Ω–¥—ã –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /help, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã.")


@dp.message_handler(state=States.QR_STATE[0], content_types=['text'])
@dp.throttled(anti_flood, rate=1)
async def check_message_qrcode(message: types.Message, state: FSMContext):
    if message.text:
        await message.answer("–í—ã –≤ —Ä–µ–∂–∏–º–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ QR-Code, —á—Ç–æ–±—ã –±–æ—Ç —Ä–∞–±–æ—Ç–∞–ª –µ–º—É –Ω–∞–¥–æ —Å–∫–∏–Ω—É—Ç—å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é")
        await state.set_state(States.all()[0])
    else:
        await state.set_state(States.all()[0])
        pass


@dp.message_handler(state=States.URL_STATE[0], content_types=['photo'])
@dp.throttled(anti_flood, rate=1)
async def check_message_qrcode(message: types.Message, state: FSMContext):
    if message.photo:
        await message.answer("–í—ã –≤ —Ä–µ–∂–∏–º–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Å—ã–ª–æ–∫, —á—Ç–æ–±—ã –±–æ—Ç —Ä–∞–±–æ—Ç–∞–ª –µ–º—É –Ω–∞–¥–æ –Ω–∞–ø–∏—Å–∞—Ç—å —Ä–∞–±–æ—á—É—é —Å—Å—ã–ª–∫—É")
        await state.set_state(States.all()[0])
    else:
        await state.set_state(States.all()[0])
        pass

if __name__ == '__main__':
    executor.start_polling(dp)
