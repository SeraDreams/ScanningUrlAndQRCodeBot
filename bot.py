import time
from urllib.parse import urlparse
from aiogram.utils import executor
from config import *
from src.convert_qrcode_to_link import get_link_qr_code
from src.link_check import check_link
from aiogram.dispatcher import FSMContext
from utils import TestStates


@dp.message_handler(commands=['start'])
@dp.message_handler(content_types=['photo'])
@dp.message_handler(text='–ù–∞—á–∞—Ç—å üìù')
async def process_start_command(message: types.Message):
    Start, URL, QRcode, Backup = '–ù–∞—á–∞—Ç—å üìù', '–û—Ç–ø—Ä–∞–≤–∏—Ç—å URL üëÄ', '–ó–∞–≥—Ä—É–∑–∏—Ç—å QR_code üñ•', '–ù–∞–∑–∞–¥ ‚Ü©Ô∏è'
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.add(Start)
    keyboard.add(URL)
    keyboard.add(QRcode)
    keyboard.add(Backup)
    await message.answer('üîÑ <b> –ë–û–¢ Information Defender </b> - –ó–ê–ü–£–°–ö–ê–ï–¢–°–Ø, –ü–û–ñ–ê–õ–£–ô–°–¢–ê, –ü–û–î–û–ñ–î–ò–¢–ï... üîÑ',
                         parse_mode='HTML')

    await message.answer(
            """
|----------------------------------
| <b>–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é —Ç–µ–±—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å!</b>
|----------------------------------
| <b>–ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥:</b>
|----------------------------------
|
|<b>---> /start - –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ </b> üñ•
|
|<b>---> /qr_code - –ü—Ä–æ–≤–µ—Ä–∫–∞ QR </b> üíæ
|
|<b>---> /url - –ü—Ä–æ–≤–µ—Ä–∫–∞ url </b> üíæ
|
|<b>---> /help - –ü–æ–º–æ—â—å </b> üîß
|
|----------------------------------
            """, parse_mode="HTML", reply_markup=keyboard)


@dp.message_handler(commands=["qr_code"])
async def cmd_qrcode(message: types.Message, state: FSMContext):
    await state.set_state(TestStates.all()[0])
    await bot.send_message(message.from_user.id, "üíæ–û—Ç–ø—Ä–∞–≤—å <b>QR-–∫–æ–¥</b>, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—á–µ—à—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å: üíæ",
                           parse_mode='HTML')


@dp.message_handler(commands=["url"])
async def cmd_url(message: types.Message, state: FSMContext):
    await state.set_state(TestStates.all()[1])
    await bot.send_message(message.from_user.id, "üíæ –ù–∞–ø–∏—à–∏ <b>URL</b>, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—á–µ—à—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å: üíæ", parse_mode='HTML')


@dp.message_handler(commands=["help"])
async def cmd_help(message: types.Message):
    Start, URL, QRcode, Backup = '–ù–∞—á–∞—Ç—å üìù', '–û—Ç–ø—Ä–∞–≤–∏—Ç—å URL üëÄ', '–ó–∞–≥—Ä—É–∑–∏—Ç—å QR_code üñ•', '–ù–∞–∑–∞–¥ ‚Ü©Ô∏è'
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.add(Start)
    keyboard.add(URL)
    keyboard.add(QRcode)
    keyboard.add(Backup)

    await message.answer(
            """
<b>–í–´ –û–ë–†–ê–¢–ò–õ–ò–°–¨ –ö –ö–û–ú–ê–ù–î–ï /help</b>
1Ô∏è‚É£ /start - –∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

2Ô∏è‚É£ /qrcode - –ø—Ä–∏ —É–∫–∞–∑–∞–Ω–∏–∏ QRcode'–∞ –≤ –¥–∞–Ω–Ω–æ–π –∫–æ–º–∞–Ω–¥–µ, –≤—ã –ø–æ–ª—É—á–∏—Ç–µ —Å—Å—ã–ª–∫—É, –∞ –∑–∞—Ç–µ–º —Å—Å—ã–ª–∫–∞ –±—É–¥–µ—Ç –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω–∞ –Ω–∞ —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ñ–∞–∫—Ç–æ—Ä—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —Å—Å—ã–ª–∫–∏ –∏ –∑–∞—Ç–µ–º –≤—ã–≤–æ–¥–∏—Ç—å—Å—è —Å–ø–∏—Å–æ–∫.

3Ô∏è‚É£ /url - –ø—Ä–∏ —É–∫–∞–∑–∞–Ω–∏–∏ —Å—Å—ã–ª–∫–∏ –≤ –¥–∞–Ω–Ω–æ–π –∫–æ–º–∞–Ω–¥–µ, –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ñ–∞–∫—Ç–æ—Ä—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏ —Ç—É—Ç –∂–µ –≤–∞–º –≤—ã–≤–æ–¥–∏—Ç—å—Å—è —Å–ø–∏—Å–æ–∫
4Ô∏è‚É£ /help - –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è, –∫–∞–∫–∏–µ –∫–æ–º–∞–Ω–¥—ã –¥–æ—Å—Ç—É–ø–Ω—ã –∏ —á—Ç–æ –æ–Ω–∏ –≤—ã–ø–æ–ª–Ω—è—é—Ç
            """, parse_mode='HTML', reply_markup=keyboard)


@dp.message_handler(text='–û—Ç–ø—Ä–∞–≤–∏—Ç—å URL üëÄ')
async def processing_url(message: types.Message, state: FSMContext):
    await state.set_state(TestStates.all()[1])
    await bot.send_message(message.from_user.id, """
üíæ –ù–∞–ø–∏—à–∏ <b>URL</b>, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—á–µ—à—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å: üíæ
""", parse_mode='HTML')


@dp.message_handler(text='–ó–∞–≥—Ä—É–∑–∏—Ç—å QR_code üñ•')
async def processing_qr_code(message: types.Message, state: FSMContext):
    await state.set_state(TestStates.all()[0])
    await bot.send_message(message.from_user.id, """
üíæ–û—Ç–ø—Ä–∞–≤—å <b>QR-–∫–æ–¥</b>, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—á–µ—à—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å: üíæ
""", parse_mode='HTML')


@dp.message_handler(text='–ù–∞–∑–∞–¥ ‚Ü©Ô∏è', state=TestStates.QR_STATE[0])
async def processing_qr_code(message: types.Message, state: FSMContext):
    await state.reset_state()
    Start, URL, QRcode, Backup = '–ù–∞—á–∞—Ç—å üìù', '–û—Ç–ø—Ä–∞–≤–∏—Ç—å URL üëÄ', '–ó–∞–≥—Ä—É–∑–∏—Ç—å QR_code üñ•', '–ù–∞–∑–∞–¥ ‚Ü©Ô∏è'
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.add(Start)
    keyboard.add(URL)
    keyboard.add(QRcode)
    keyboard.add(Backup)
    await message.answer('üîÑ <b>–ò–î–Å–¢ –ü–ï–†–ï–ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï –í –ì–õ–ê–í–ù–û–ï –û–ö–ù–û, –ü–û–ñ–ê–õ–£–ô–°–¢–ê, –ü–û–î–û–ñ–î–ò–¢–ï...</b> üîÑ', parse_mode='HTML')

    await message.answer(
            """
|----------------------------------
| <b>–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é —Ç–µ–±—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å!</b>
|----------------------------------
| <b>–ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥:</b>
|----------------------------------
|
|<b>---> /start - –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ </b> üñ•
|
|<b>---> /qr_code - –ü—Ä–æ–≤–µ—Ä–∫–∞ QR </b> üíæ
|
|<b>---> /url - –ü—Ä–æ–≤–µ—Ä–∫–∞ url </b> üíæ
|
|<b>---> /help - –ü–æ–º–æ—â—å </b> üîß
|
|----------------------------------
            """, parse_mode="HTML", reply_markup=keyboard)


@dp.message_handler(text='–ù–∞–∑–∞–¥ ‚Ü©Ô∏è', state=TestStates.URL_STATE[0])
async def processing_url(message: types.Message, state: FSMContext):
    await state.reset_state()
    Start, URL, QRcode, Backup = '–ù–∞—á–∞—Ç—å üìù', '–û—Ç–ø—Ä–∞–≤–∏—Ç—å URL üëÄ', '–ó–∞–≥—Ä—É–∑–∏—Ç—å QR_code üñ•', '–ù–∞–∑–∞–¥ ‚Ü©Ô∏è'
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.add(Start)
    keyboard.add(URL)
    keyboard.add(QRcode)
    keyboard.add(Backup)
    await message.answer('üîÑ <b>–ò–î–Å–¢ –ü–ï–†–ï–ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï –í –ì–õ–ê–í–ù–û–ï –û–ö–ù–û, –ü–û–ñ–ê–õ–£–ô–°–¢–ê, –ü–û–î–û–ñ–î–ò–¢–ï...</b> üîÑ', parse_mode='HTML')

    await message.answer(
            """
|----------------------------------
| <b>–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é —Ç–µ–±—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å!</b>
|----------------------------------
| <b>–ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥:</b>
|----------------------------------
|
|<b>---> /start - –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ </b> üñ•
|
|<b>---> /qr_code - –ü—Ä–æ–≤–µ—Ä–∫–∞ QR </b> üíæ
|
|<b>---> /url - –ü—Ä–æ–≤–µ—Ä–∫–∞ url </b> üíæ
|
|<b>---> /help - –ü–æ–º–æ—â—å </b> üîß
|
|----------------------------------
            """, parse_mode="HTML", reply_markup=keyboard)


@dp.message_handler(state=TestStates.URL_STATE[0])
async def solution_url(message: types.Message, state: FSMContext):
    url = message.text
    await message.reply \
        ("""                    
üîÖ –ò–¥—ë—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Å—ã–ª–∫–∏... üîÖ                               
        """, reply=False)
    time.sleep(1)
    try:
        parsed_url = urlparse(url)
        domain = parsed_url.scheme + '://' + parsed_url.netloc + '/'
        result = check_link(domain)
        galochka, krestik = '‚úÖ', '‚ùå'
        time.sleep(1)
        card = \
            f'|----------------------------------\n' \
            f'|\n' \
            f'|<b>----> URL:</b> {domain}\n' \
            f'|<b>----> –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è:</b>     {krestik if result["redirect"] == True else galochka}\n' \
            f'|<b>----> –ü–æ–¥–¥–µ—Ä–∂–∫–∞ https:</b>          {galochka}\n' \
            f'|<b>----> SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç:</b>              {galochka if result["ssl"] == True else krestik}\n' \
            f'|<b>----> –ò–∑–≤–µ—Å—Ç–Ω—ã–π –¥–æ–º–µ–Ω:</b>           {krestik if result["suspicious"] == True else galochka}\n' \
            f'|<b>----> –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π JS –∫–æ–¥:</b> {krestik if result["suspicious_js"] == False else galochka}\n' \
            f'|<b>----> –î–æ–º–µ–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω–∏:</b>           {krestik if result["Long level"] == True else galochka}\n' \
            f'|<b>----> –ß–∏—Ç–∞–µ–º—ã–π –¥–æ–º–µ–Ω:</b>           {krestik if result["Unreadability"] == True else galochka}\n' \
            f'|\n' \
            f'|----------------------------------'
        await message.reply(card, reply=False)
        await state.reset_state()
    except:
        try:
            parsed_url = urlparse(url)
            domain = 'http://' + parsed_url.netloc + '/'
            result = check_link(domain)
            galochka, krestik = '‚úÖ', '‚ùå'

            time.sleep(1)
            await message.reply(
                    """
<b>‚ö†Ô∏è–ù–∞–π–¥–µ–Ω –∑–∞–ø—Ä–µ—Ç –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ https‚ö†Ô∏è</b>
<b>üñ•–ò–¥—ë—Ç –∑–∞–º–µ–Ω–∞ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ https...üñ•</b>
                    """, parse_mode='HTML', reply=False)
            time.sleep(1)
            card = \
                f'|----------------------------------\n' \
                f'|\n' \
                f'|<b>----> URL:</b> {domain}\n' \
                f'|<b>----> –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è:</b>     {krestik if result["redirect"] == True else galochka}\n' \
                f'|<b>----> –ü–æ–¥–¥–µ—Ä–∂–∫–∞ https:</b>          {galochka}\n' \
                f'|<b>----> SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç:</b>              {galochka if result["ssl"] == True else krestik}\n' \
                f'|<b>----> –ò–∑–≤–µ—Å—Ç–Ω—ã–π –¥–æ–º–µ–Ω:</b>           {krestik if result["suspicious"] == True else galochka}\n' \
                f'|<b>----> –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π JS –∫–æ–¥:</b> {krestik if result["suspicious_js"] == False else galochka}\n' \
                f'|<b>----> –î–æ–º–µ–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω–∏:</b>           {krestik if result["Long level"] == True else galochka}\n' \
                f'|<b>----> –ß–∏—Ç–∞–µ–º—ã–π –¥–æ–º–µ–Ω:</b>           {krestik if result["Unreadability"] == True else galochka}\n' \
                f'|\n' \
                f'|----------------------------------'
            await message.reply(card, parse_mode="HTML", reply=False)
            await state.reset_state()
        except:
            await message.reply(
                """
|----------------------------------
|                ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
|----------------------------------                
|           <b>–û–®–ò–ë–ö–ê URL</b>
|----------------------------------
|   <b>–ü—Ä–∏—á–∏–Ω–æ–π –º–æ–∂–µ—Ç –±—ã—Ç—å:</b>
|----------------------------------
|
|---> 1Ô∏è‚É£ - –ù–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –¥–æ–º–µ–Ω
|
|---> 2Ô∏è‚É£ - –ù–µ —É–∫–∞–∑–∞–Ω –ø—Ä–æ—Ç–æ–∫–æ–ª
|
|---> 3Ô∏è‚É£ - –°—Å—ã–ª–∫–∞ –ª–æ–∫–∞–ª—å–Ω–∞—è
|
|----------------------------------
                """, parse_mode='HTML', reply=False)
            await state.reset_state()


@dp.message_handler(state=TestStates.QR_STATE[0], content_types=['photo'])
async def solution_QRcode(message: types.Message, state: FSMContext):
    await message.reply("üìé –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–∫–∞—á–∏–≤–∞–µ—Ç—Å—è... üìé ", reply=False)
    time.sleep(1)
    user_id = message.from_user.id
    await message.photo[-1].download(f'src/img_{user_id}.png')
    try:
        url = get_link_qr_code(user_id=user_id)
        await message.reply("""                    
        üîÖ –ò–¥—ë—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—Å—ã–ª–∫–∏... üîÖ                               
            """, reply=False)
        time.sleep(1)
        try:
            time.sleep(1)
            parsed_url = urlparse(url)
            domain = parsed_url.scheme + '://' + parsed_url.netloc + '/'
            result = check_link(domain)
            galochka, krestik = '‚úÖ', '‚ùå'
            card = \
                f'|----------------------------------\n' \
                f'|\n' \
                f'|<b>----> URL:</b> {domain}\n' \
                f'|<b>----> –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è:</b>     {krestik if result["redirect"] == True else galochka}\n' \
                f'|<b>----> –ü–æ–¥–¥–µ—Ä–∂–∫–∞ https:</b>          {galochka}\n' \
                f'|<b>----> SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç:</b>              {galochka if result["ssl"] == True else krestik}\n' \
                f'|<b>----> –ò–∑–≤–µ—Å—Ç–Ω—ã–π –¥–æ–º–µ–Ω:</b>           {krestik if result["suspicious"] == True else galochka}\n' \
                f'|<b>----> –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π JS –∫–æ–¥:</b> {krestik if result["suspicious_js"] == False else galochka}\n' \
                f'|<b>----> –î–æ–º–µ–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω–∏:</b>           {krestik if result["Long level"] == True else galochka}\n' \
                f'|<b>----> –ß–∏—Ç–∞–µ–º—ã–π –¥–æ–º–µ–Ω:</b>           {krestik if result["Unreadability"] == True else galochka}\n' \
                f'|\n' \
                f'|----------------------------------'
            await message.reply(card, reply=False)
            await state.reset_state()
        except:
            try:
                time.sleep(1)
                parsed_url = urlparse(url)
                domain = 'http://' + parsed_url.netloc + parsed_url.path
                site = 'https://' + parsed_url.netloc
                result = check_link(domain)
                galochka, krestik = '‚úÖ', '‚ùå'
                await message.reply(
                    """
<b>‚ö†Ô∏è–ù–∞–π–¥–µ–Ω –∑–∞–ø—Ä–µ—Ç –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ https‚ö†Ô∏è</b>
<b>üñ•–ò–¥—ë—Ç –∑–∞–º–µ–Ω–∞ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ https...üñ•</b>
                    """, parse_mode='HTML', reply=False)
                time.sleep(1)
                card = \
                    f'|----------------------------------\n' \
                    f'|\n' \
                    f'|<b>----> URL:</b> {site}\n' \
                    f'|<b>----> –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è:</b>     {krestik if result["redirect"] == True else galochka}\n' \
                    f'|<b>----> –ü–æ–¥–¥–µ—Ä–∂–∫–∞ https:</b>          {galochka}\n' \
                    f'|<b>----> SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç:</b>              {galochka if result["ssl"] == True else krestik}\n' \
                    f'|<b>----> –ò–∑–≤–µ—Å—Ç–Ω—ã–π –¥–æ–º–µ–Ω:</b>           {krestik if result["suspicious"] == True else galochka}\n' \
                    f'|<b>----> –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π JS –∫–æ–¥:</b> {krestik if result["suspicious_js"] == True else galochka}\n' \
                    f'|<b>----> –î–æ–º–µ–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω–∏:</b>           {krestik if result["Long level"] == True else galochka}\n' \
                    f'|<b>----> –ß–∏—Ç–∞–µ–º—ã–π –¥–æ–º–µ–Ω:</b>           {krestik if result["Unreadability"] == True else galochka}\n' \
                    f'|\n' \
                    f'|----------------------------------'
                await message.reply(card, parse_mode='HTML', reply=False)
                await state.reset_state()
            except:
                await message.reply("<b>‚ö†Ô∏è –°—Å—ã–ª–∫–∞ –≤ QR-–∫–æ–¥–µ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è... ‚ö†Ô∏è</b>", parse_mode='HTML', reply=False)
                await state.reset_state()
    except:
        await message.reply(
            """
|----------------------------------
|                ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
|----------------------------------                
|       <b>–û–®–ò–ë–ö–ê QR-–ö–û–î–ê</b>
|----------------------------------
|   <b>–ü—Ä–∏—á–∏–Ω–æ–π –º–æ–∂–µ—Ç –±—ã—Ç—å:</b>
|----------------------------------
|
|---> 1Ô∏è‚É£ - –ü–ª–æ—Ö–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç–∏–Ω–∫–∏
|
|---> 2Ô∏è‚É£ - QR-–∫–æ–¥ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω
|
|---> 3Ô∏è‚É£ - –ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ñ–æ—Ä–º–∞—Ç
|
|----------------------------------
            """, parse_mode='HTML', reply=False)
        await state.reset_state()





if __name__ == '__main__':
    executor.start_polling(dp)
